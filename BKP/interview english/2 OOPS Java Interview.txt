OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































OOPS Java Interview Questions: 

Q1. What is Polymorphism? 
Polymorphism is briefly described as "one interface, many implementations". 
Polymorphism is a characteristic of being able to assign a different meaning or usage to 
something in different contexts - specifically, to allow an entity such as a variable, a 
function, or an object to have more than one form. There are two types of 
polymorphism:
1.	Compile time polymorphism
2.	Run time polymorphism
 
Compile time polymorphism is method overloading whereas Runtime time 
polymorphism is done using inheritance and interface.
Q2. What is runtime polymorphism or dynamic method dispatch?
In Java, runtime polymorphism or dynamic method dispatch is a process in which a call 
to an overridden method is resolved at runtime rather than at compile-time. In this 
process, an overridden method is called through the reference variable of a 
superclass. Let's take a look at the example below to understand it better.

class Car {
void run()
{
System.out.println("car is running"); 
}
}
class Audi extends Car {
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main(String args[])
{
Car b= new Audi();    //upcasting
b.run();
}
}
Q3. What is the difference between abstract classes and 
interfaces?
Abstract Class - An abstract class can provide complete, default code and/or just 
the details that have to be overridden. In case of abstract class, a class may extend only 
one abstract class. An abstract class can have non-abstract methods. An abstract class 
can have instance variables. An abstract class can have any visibility: public, private, 
protected. If we add a new method to an abstract class then we have the option of 
providing default implementation and therefore all the existing code might work properly. 
An abstract class can contain constructors. Abstract classes are fast.
Interfaces - An interface cannot provide any code at all,just the signature. A Class 
may implement several interfaces. All methods of an Interface are abstract. An Interface 
cannot have instance variables. An Interface visibility must be public (or) none. If we 
add a new method to an Interface then we have to track down all the implementations of 
the interface and define implementation for the new method. An Interface cannot 
contain constructors. Interfaces are slow as it requires extra indirection to find 
corresponding method in the actual class

Q4. What is method overloading and method overriding?
Method Overloading :
*	In Method Overloading, Methods of the same class shares the same name but 
each method must have different number of parameters or parameters having 
different types and order.
*	Method Overloading is to "add" or "extend" more to method's behavior.
*	It is a compile time polymorphism.
*	The methods must have different signature.
*	It may or may not need inheritance in Method Overloading.
Let's take a look at the example below to understand it better.

class Adder {
Static int add(int a, int b)
{
return a+b;
}
Static double add( double a, double b)
{
return a+b;
}
public static void main(String args[])
{
System.out.println(Adder.add(11,11));
System.out.println(Adder.add(12.3,12.6));
}}
Method Overriding:  
*	In Method Overriding, sub class have the same method with same name and 
exactly the same number and type of parameters and same return type as a 
super class.
*	Method Overriding is to "Change" existing behavior of method.
*	It is a run time polymorphism.
*	The methods must have same signature.
*	It always requires inheritance in Method Overriding.
Let's take a look at the example below to understand it better.

class Car {
void run(){
System.out.println("car is running"); 
}
Class Audi extends Car{
void run()
{
System.out.prinltn("Audi is running safely with 100km");
}
public static void main( String args[])
{
Car b=new Audi();
b.run();
}
}
Q5. Can you override a private or static method in Java?
You cannot override a private or static method in Java. If you create a similar method 
with same return type and same method arguments in child class then it will hide the 
super class method; this is known as method hiding. Similarly, you cannot override a 
private method in sub class because it's not accessible there. What you can do is create 
another private method with the same name in the child class. Let's take a look at the 
example below to understand it better.

class Base {
private static void display() {
System.out.println("Static or class method from Base");
}
public void print() {
System.out.println("Non-static or instance method from Base");
}
class Derived extends Base {
private static void display() {
System.out.println("Static or class method from Derived");
}
public void print() {
System.out.println("Non-static or instance method from Derived");
}
public class test {
public static void main(String args[])
{
Base obj= new Derived();
obj1.display();
obj1.print();
}
}
Q6. What is multiple inheritance? Is it supported by Java?
 If a child class inherits the property from multiple classes is 
known as multiple inheritance. Java does not allow to extend multiple classes.
The problem with multiple inheritance is that if multiple parent classes have a same 
method name, then at runtime it becomes difficult for the compiler to decide which 
method to execute from the child class.
Therefore, Java doesn't support multiple inheritance. The problem is commonly referred 
as Diamond Problem.
 
Q7. What is association?
Association is a relationship where all object have their own lifecycle and there is no 
owner. Let's take an example of Teacher and Student. Multiple students can associate 
with a single teacher and a single student can associate with multiple teachers but there 
is no ownership between the objects and both have their own lifecycle. These 
relationship can be one to one, One to many, many to one and many to many.
Q8. What do you mean by aggregation?
Aggregation is a specialized form of Association where all object have their own 
lifecycle but there is ownership and child object can not belongs to another parent 
object. Let's take an example of Department and teacher. A single teacher can not 
belongs to multiple departments, but if we delete the department teacher object will not 
destroy. 
Q9. What is composition in Java?
Composition is again specialized form of Aggregation and we can call this as a "death" 
relationship. It is a strong type of Aggregation. Child object dose not have their lifecycle 
and if parent object deletes all child object will also be deleted. Let's take again an 
example of relationship between House and rooms. House can contain multiple rooms 
there is no independent life of room and any room can not belongs to two different 
house if we delete the house room will automatically delete.



































